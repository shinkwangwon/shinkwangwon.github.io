---
layout: post
title: "Java 컴파일과정 및 클래스 로더"
tags: [java]
comments: true
date: 2019-12-06
---

## Java 컴파일 과정
1. 개발자가 작성한 .java 파일을 토대로 컴파일러(javac)가 .class(=바이트코드)를 생성해낸다.
  - 어휘 분석(Lexical Ananlysis) : 소스코드를 문자 단위로 읽어서 유의미한 토큰을 만듬
  - 구문 분석(Syntax Analysis) : Parser라고도 하며 어휘분석의 결과로 나온 토큰들이 정해진 문법에 맞는지 검사 후 파스트리 생성. 맞지 않으면 컴파일 에러
  - 의미 분석(Symantic Analysis) : 타입 검사, 자동 타입 변환 등 검사
  - 중간 코드 생성(Intermediate Code Generation) : 기계어로 변환하기 좋은 형태로 코드를 생성. 자바의 바이트 코드에 해당한다고 볼 수 있음. 이 단계에서 클래스나 인터페이스별 상수 풀이 만들어진다. 상수 풀에 저장된 정보는 해당 클래스나 인터페이스가 실제 생성될 때 런타임 상수 풀을 구성하는데 사용된다.
  - 중간 코드 최적화(Code Optimization) : 더 효율적인 기계어로 변환될 수 있도록 최적화 과정 수행
2. Class Loader는 바이트코드를 토대로 JVM이 운영체제로부터 할당받은 메모리 영역인 Runtime Data Area로 적재하는 역할을 한다.
  - 런타임 시에 동적으로 클래스를 메모리 영역에 배치 시킨다.
3. 실행 엔진은 Class Loader에 의해 메모리에 적재된 바이트 코드를 기계어로 변경해 명령어 단위로 실행하는 역할을 한다.
  - 자바 실행엔진 종류
  - Interprter (인터프리터) : 자바 바이트 코드를 한줄씩 해석하며 기계어 코드로 변환 후 실행하는 방식으로 한줄한줄에 대한 해석은 빠르나 인터프리팅 결과의 실행은 느리다는 단점이 있다. 
  - JIT Compiler (Just In Time) : 인터프리터의 단점을 보완하기위해 나온 컴파일러다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일해 네이티브 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드를 실행하는 것이 하나씩 인터프리팅하는 것보다 빠르고, 네이티브 코드는 캐시에 보관하기 때문에 한번 컴파일된 코드는 계속 빠르게 실행된다.
  

## 클래스 로더
1. 정의
- 자바는 동적 로드, 즉 컴파일 타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더다.
- 각 클래스 로더에는 로드된 클래스를 보관하는 네임스페이스가 있다. 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해 네임스페이스에 보관된 네임을 기준으로 클래스를 찾는다.
- 클래스 로더가 클래스 로드를 요청 받으면 클래스 로더캐시, 상위클래스로더, 자기 자신의 순서로 해당 클래스가 있는지 확인한다. 최상위 클래스로더까지 확인해도 없으면 요청받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾는다.

2. 특징
- 계층 구조 : 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더(bootstrap class loader)다.
- 위임 모델 : 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 작동한다. 클래스를 로드할 때 먼저 상위 클래스 로더를 확인해 상위 클래스 로더에 있다면 해당 클래스를 사용하고, 없다면 요청받은 클래스로더가 클래스를 로드한다.
- 가시성(visibility) 제한 : 하위 클래스 로더는 상위 클래스 로더의 클래스를 찾을 수 있지만, 상위 클래스 로더는 하위 클래스 로더의 클래스를 찾을 수 없다. 
- 언로드(Unload) 불가 : 클래스 로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 언로드 대신 현재 클래스 로더를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있다.

3. 종류
- 부트스트랩 클래스 로더(bootstrap class loader) : JVM을 가동할 때 생성되며, Object클래스를 비롯해 JVM을 실행에 필요한 가장 기본적인 클래스들을 로드한다. 다른 클래스 로더와 달리 자바가 아니라 네이티브 코드로 구현되어 있다.
- 확장 클래스 로더(extension class loader) : 확장클래스를 로드한다. 다양한 보안 확장 기능 등을 여기에서 로드한다.
- 시스템 클래스 로더(system class loader) : 부트스트랩 클래스 로더와 확장 클래스 로더가 JVM자체의 구성 요소를 로드한다면, 시스템 클래스 로더는 어플리케이션 클래스를 로드한다고 할 수 있다. 사용자가 지정한 $CLASSPATH 내의 클래스를 로드한다.
- 사용자 정의 클래스 로더(user-defined class loader): 어플리케이션 사용자가 직접 코드 상에서 생성해서 사용하는 클래스 로더다. 웹 어플리케이션 서버(WAS)와 같은 컨테이너는 웹 어플리케이션과 엔터프라이즈 어플리케이션이 서로 독립적으로 작동하도록 사용자 정의 클래스 로더를 사용한다. 즉, 클래스 로더의 위임모델을 통해 어플리케이션의 독립성을 보장한다. 이와 같은 WAS의 클래스 로더 구조는 WAS 제조사마다 조금씩 다른 형태의 계층 구조를 사용하고 있다. (ex: WAR 클래스로더)

## 클래스 로드 단계
1. 로드(loading) : 클래스를 파일에서 가져와 JVM의 메모리에 로드한다.
2. 검증(verifying) : 읽어들인 클래스가 자바 언어 명세 및 JVM명세에 명시된 대로 잘 구성됐는지 검사한다. 클래스 로드의 전 과정 중에서 가장 까다로운 검사를 실행하는 과정이며 가장 복잡하고 시간이 많이 걸린다. JVM TCK의 테스트 케이스 중에서 가장 많은 부분이, 잘못된 클래스를 로드해 정상적으로 검증 오류를 발생시키는지 테스트 하는 부분이다.
> TCK : 오라클은 클래스 파일 검증을 위해 TCK(Technology Compatibility Kit)라는 테스트 도구를 제공한다.  
3. 준비(preparing) : 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메소드, 인터페이스를 나타내는 데이터 구조를 준비한다.
4. 분석(resolving): 클래스의 상수 풀 내 모든 심벌릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
5. 초기화(initializing) : 클래스 변수를 적절한 값으로 초기화한다. 즉 static initializer를 실행하고, static 필드를 설정된 값으로 초기화 한다.


## JVM 메모리 구조
- [Java JVM 메모리 구조](https://shinkwangwon.github.io/jvm-memory/)




#### 참고
- <https://homoefficio.github.io/2019/01/31/Back-to-the-Essence-Java-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EC%84%9C-%EC%8B%A4%ED%96%89%EA%B9%8C%EC%A7%80-1/>
- 서적 : 네이버를 만든 기술, 읽으면서 배운다 - 자바편
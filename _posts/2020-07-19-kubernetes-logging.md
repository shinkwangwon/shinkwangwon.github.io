---
layout: post
title: "Kubernetes Logging"
tags: [kubernetes]
comments: true
date: 2020-07-19
---

## Logging

- 클러스터 환경에서는 특별한 상황을 제외하고 로그를 로컬 디스크에 파일로 저장하는 것을 지양해야 한다.
- 전통적인 애플리케이션 운영 환경에서는 지정된 위치에 파일로 로그를 저장하도록 구성하는데, 이런 방식은 애플리케이션이 항상 지정된 장비에서 실행된다는 것을 가정하기 때문에 가능한 것이다.
- 쿠버네티스에서 컨테이너는 상황에 따라 클러스터 안 여러 노드를 옮겨다니기 때문에 특정 앱 컨테이너의 로그를 확인하려면 전체 클러스터의 노드 중 어떤 노드에서 해당 앱 컨테이너가 실행되었는지 확인해야 로그확인도 가능하다. 쿠버네티스는 이를 위해 개별 노드에 들어갈 필요없이 kubectl logs 를 통해 직접 pod의 로그를 확인할 수 있는 기능을 제공한다.
- 컨테이너화된 애플리케이션이 STDOUT/STDERR 에 쓰는 모든 것은 컨테이너 엔진에 의해 어딘가에서 처리와 redirect 된다. 도커 컨테이너 엔진 같은 경우는 이 2개의 스트림을 로깅 드라이버로 리다이렉트 한다. 도커는 syslog, journal, json-file 같은 로깅 드라이버를 지원하며 쿠버네티스에서는 기본적으로 json-file을 사용한다.

## Pod 로그 확인하기

- 쿠버네티스의 kubectl은 개별 노드에 접근하지 않고 파드의 로그를 확인 할 수 있다.
- kubectl logs -f ${pod name}
    - -f 옵션 : 실행 중인 로그 지속해서 수집하도록 tailing 수행

## 클러스터 레벨 로깅

- 컨테이너가 비정상 종료되거나 노드에 장애가 있더라도 앱 컨테이너의 로그를 확인할 수 있어야 한다. 그러므로 컨테이너,파드,노드의 생명주기와 분리된 스토리지를 구축해야 한다.
- 또한 로그를 로컬 디스크에 쌓을 경우 로컬 디스크 용량 문제로 로그 로테이션이 발생하면 로그가 유실될 가능성이 있기 때문에 로그를 한 곳에 모아 관리하는 방식을 추구한다.
- 쿠버네티스에서는 생명 주기와 분리된 스토리지를 구축하는 아키텍처를 클러스터 레벨 로깅이라고 한다. 쿠버네티스 자체에서 클러스터 레벨 로깅 도구를 제공하지 않기 때문에 kafka, fluentd, logstash, elasticsearch, kibana 등 외부 도구를 사용해야 한다.

## 쿠버네티스 모니터링 구성요소

- 시스템 메트릭
    - 노드나 컨테이너의 CPU, 메모리 사용량 같은 시스템 관련 메트릭
- 서비스 메트릭
    - 애플리케이션을 모니터링할 때 필요한 메트릭
- 코어 메트릭 파이프라인
    - 쿠버네티스 관련 구성 요소를 직접 관리하는 파이프라인
    - 코어 시스템 메트릭(노드,파드,컨테이너의 사용량 정보 등)을 수집해 핵심 요소의 모니터링 담당
- 모니터링 파이프라인
    - 쿠버네티스 시스템보다는 클러스터 사용자에게 필요한 모니터링에 관련된 메트릭 수집
    - 쿠버네티스는 모니터링 파이프라인을 직접 관리하지 않기 때문에 외부 모니터링 시스템을 연계해야함
    - 힙스터, 프로메테우스 등

## 프로메테우스 (Prometheus)

- 모니터링 데이터 수집은 프로메테우스 서버가 수집하려는 대상에서 데이터를 pulling 하는 구조이다.
- Exporter가 정보를 수집하여 Http end point를 열고 프로메테우스가 Exporter로 부터 주기적으로 데이터를 pull 한다.
- Exporter는 모니터링 에이전트로 타겟 시스템에서 메트릭을 읽어서, 프로메테우스가 pulling 할 수 있도록 한다. 요청 당시의 데이터를 리턴하는 것일뿐, Exporter 자체는 히스토리를 저장하는 등의 기능은 없다. 즉, pulling 하는 순간의 메트릭 스냅샷을 가져오기 때문에 pulling 주기에 따라 메트릭 수치가 달라질 수 있다.

## PV (PersistentVolume) & PVC (PersistentVolumeClaim)

- PV는 볼륨 자체를 뜻하고 클러스터 자원으로 다룬다. pod하고는 별개로 관리되고 별도의 생명 주기가 있다.
- PVC는 사용자의 PV에 대한 요청이다. PV에 대해 사용하고 싶은 용량은 얼만큼이고 Read/Write 는 어떤 mode로 설정하고 싶은지 등을 정해서 요청하는 것을 말한다.
- PV에서 제공하는 접근 모드는 아래와 같으며, PVC는 아래 중 1가지 방식으로 요청할 수 있다.
    - ReadWriteOnce : 노드 하나에만 볼륨을 읽기/쓰기하도록 마운트 할 수 있음
    - ReadOnlyMany : 여러개의 노드에서 읽기 전용으로 마운트 할 수 있음
    - ReadWriteMany : 여러개의 노드에서 읽기/쓰기 가능하도록 마운트할 수 있음
- 쿠버네티스는 볼륨을 pod에 직접 할당하는 방식이 아니라 중간에 PVC를 두어 pod와 pod가 사용할 스토리지를 분리했다. 실제 볼륨 서비스는 직접 구축한 스토리지, 클라우드 서비스에서 제공해주는 볼륨 등 여러가지를 사용할 수 있는데. 중간에 PVC가 있기 때문에 pod 입장에서는 어떤 스토리지를 사용하는지 신경쓰지 않아도 된다.
- PersistentVolumeTemplate : PV를 생성하기 위한 템플릿
- PersistentVolumeClaimTemplate : PVC를 생성하기 위한 템플릿

## Provisioning

- PV를 만드는 단계를 프로비저닝이라고 한다.
- 정적 provisioning
    - 클러스터 관리자가 미리 적정 용량의 PV를 만들어두고 사용자의 요청이 있으면 미리 만들어둔 PV를 할당. 미리 만들어둔 PV보다 큰 용량을 요청할 경우 요청 실패
- 동적 provisioning
    - 사용자가 PVC를 거쳐서 PV를 요청했을 때 생성한 후 제공
    - 동적 프로비저닝할 때 여러가지 스토리지 중 스토리지를 정의하는 StorageClass로 PV를 생성
- 바인딩
    - 프로비저닝으로 만든 PV를 PVC와 연결하는 단계
    - PVC에서 원하는 스토리지의 용량과 접근 방법을 명시해서 요청하면 걸맞는 PV가 할당됨. 만약 원하는 PV가 없다면 요청은 실패하지만, 원하는 PV가 생길때까지 대기하다가 PVC에 바인딩 된다.
    - PV와 PVC는 1:1 매핑관계이며 PVC하나가 여러 개의 PV에 바인딩될 수 없다.
- PVC 사용
    - PVC는 pod에 설정되고 pod는 PVC를 볼륨으로 인식해서 사용한다.
    - 할당된 PVC는 pod를 유지하는 동안 계속 사용하며 시스템에서 임의로 삭제할 수 없다.

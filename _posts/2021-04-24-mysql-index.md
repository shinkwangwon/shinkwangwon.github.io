---
layout: post
title: "MySQL Index"
tags: [mysql]
comments: true
date: 2021-04-24
---

# 5. 인덱스

## 5.1 디스크 읽기 방식

### 5.1.1 저장매체

**내장 디스크 (Internal Disk)**

- 개인용 PC 본체 내에 장착된 디스크와 같은 매체. 서버용은 개인용PC 보다 성능이 좋긴 하지만, 본체 내부 공간이 제한적이기 때문에 장착할 수 있는 디스크의 개수가 한정적임

**DAS (Direct Attached Storage)**

- DAS 장치는 독자적으로 사용 불가하고 컴퓨터 본체에 연결해서만 사용 가능
- DAS나 내장 디스크 모두 SATA, SAS와 같은 케이블로 연결되기 때문에 실제 사용자는 거의 같은 방식으로 사용
- DAS는 본체 내부에 장착하지 않고 디스크로만 이루어져있기 때문에 내장디스크 보다 훨씬 큰 용량 사용 가능
- 다만, 반드시 하나의 컴퓨터 본체에만 연결해서 사용할 수 있기 때문에 디스크의 정보를 여러 컴퓨터가 동시에 공유하는 것이 불가능

**NAS (Network Attached Storage)**

- TCP/IP를 통해 연결되며 여러 컴퓨터에서 동시에 공유해서 사용 가능
- 당연히 SATA나 SAS 방식의 직접연결보다 속도가 느리기 때문에 빈번한 데이터 읽기/쓰기 작업이 필요한 데이터베이스 서버용으로는 거의 사용되지 않음

**SAN (Storage Area Network)**

- DAS로는 구축할 수 없는 아주 대용량의 스토리지 공간을 제공하는 장치
- 여러 컴퓨터에서 동시에 사용할 수 있고 컴퓨터 본체와 광케이블로 연결되기 때문에 상당히 빠르고 안정적이지만 고가의 구축비용이 필요

### 5.1.3 랜덤 I/O 와 순차 I/O

- 랜덤I/O는 순차 I/O에 비해 처리속도가 느림 (3개의 데이터를 디스크에 기록하기 위해 순차I/O는 1번만 디스크의 위치를 찾으면 되지만,  랜덤 I/O는 3번의 디스크 기록 위치를 찾아야 함)
- 데이터베이스 대부분의 작업은 작은 데이터를 빈번히 읽고 쓰는 랜덤 I/O 작업
- 일반적으로 쿼리를 튜닝하는 것은 랜덤I/O를 순차I/O로 바꾸는 것이 아니라 랜덤I/O 자체를 줄여주는 것이 목적
- 인덱스 레인지 스캔은 주로 랜덤I/O를 사용하며 풀 테이블 스캔은 순차I/O를 사용. 그래서 큰 테이블의 레코드 대부분을 읽는 작업에서는 인덱스를 사용하지 않고 풀 테이블 스캔을 사용하도록 유도할때도 있음

## 5.2 인덱스란 ?

**정의**

- 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 Key&Value로 만들어서 정렬해 놓은 것
- 인덱스는 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 느리지만, 정렬되어 있기 때문에 원하는 값을 빨리 찾을 수 있음
- 즉, DBMS에서 인덱스는 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하는 대신 데이터의 읽기 속도를 높이는 기능 (SELECT속도를 위해 인덱스를 많이 생성할수록 데이터의 저장 성능이 떨어짐)

**역할로 구분짓는 인덱스**

- Primary key
    - 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스 (식별자)
    - 중복을 허용하지 않으며 NULL값 또한 허용하지 않음
- Secondary Key (보조키)
    - Primary key를 제외한 나머지 모든 인덱스는 보조인덱스로 분류
    - 유니크 인덱스는 Primary key 와 성격이 비슷하고, PK를 대체할 수 있기 때문에 대체키라고도 하는데, 별도로 분류하기도 하고 그냥 보조 인덱스로 분류하기도 함

**데이터 저장방식으로 보는 인덱스**

- B-Tree 인덱스 (Balanced-Tree)
    - 칼럼의 값을 변형하지 않고 원래의 값을 이용해 인덱싱하는 알고리즘
    - Balanced-Tree: 트리의 노드가 한 방향으로 쏠리지 않도록, 노드 삽입 및 삭제 시 특정 규칙에 맞게 재 정렬되어 왼쪽과 오른쪽 자식 양쪽 수의 밸런스를 유지하는 트리이다. 항상 양쪽 자식의 밸런스를 유지하므로, 무조건 O(logN)의 시간 복잡도를 가지게 된다. 다만 재정렬되는 작업으로 인해 노드 삽입 및 삭제 시 일반적인 트리보다 성능이 떨어지게 된다. 그러므로 밸런스 트리는 삽입/삭제의 성능을 희생하고 탐색에 대한 성능을 높였다고 볼 수 있다. 이진트리와 다르게 여러 자식노드를 가질 수 있다.
- Hash 인덱스
    - 칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘으로 매우 빠른 검색을 지원
    - 값을 변형해서 인덱싱하므로 전방(Prefix)일치와 같이 값의 일부만 검색하거나 범위 검색할 때는 해시 인덱스 사용 불가
    - 주로 메모리 기반의 데이터베이스에서 사용
- Fractal-Tree
    - B-Tree의 단점을 보완하기 위해 고안된 것으로 값을 변형하지 않고 인덱싱하는 것은 B-Tree와 비슷하지만, 데이터가 저장/삭제될 때 처리 비용을 상당히 줄일 수 있게 설계됨

## 5.3 B-Tree 인덱스

- 가장 일반적으로 사용되는 인덱싱 알고리즘
- B-Tree는 Binary-Tree(이진트리)로 잘못알고 있는 경우가 많은데 Balanced-Tree를 뜻함
- B-Tree는 칼럼의 원래 값을 변형시키지 않고 인덱스 구조체 내에서는 항상 정렬된 상태를 유지
- 전문 검색과 같은 특수한 요건이 아닌 경우, 대부분 인덱스는 B-Tree를 사용할 정도로 일반적인 알고리즘

### 5.3.1 구조 및 특성

![No image](/assets/posts/20210424/btree.png)

- B-Tree는 트리구조의 최상위에 하나의 "루트 노드"가 존재하고, 그 하위에 자식 노드가 붙어 있는 형태
- 트리 구조의 가장 하위에 있는 노드를 "리프(leaf) 노드"라 하고, 루트노드도 아니고 리프노트도 아닌 중간의 노드를 "브랜치 노드"라고 함
- 인덱스와 실제 저장된 데이터는 따로 관리되며, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있음
- 인덱스의 키 값은 모두 정렬되어 있지만, 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서대로 저장되어 있음
- 데이터 파일의 레코드는, 레코드가 삭제되어 빈 공간이 생기면 삭제된 공간에 레코드가 삽입되기 때문에 항상 INSERT된 순서대로 저장되는 것은 아님 ( innoDB 테이블은 예외)
- 대부분 RDBMS의 데이터 파일에서 레코드는 임의의 순서대로 저장되지만, innoDB 테이블에서 레코드는 프라이머리 키를 기준으로 클러스터되어 디스크에 저장되기 때문에, 기본적으로 프라이머리 키 순서대로 정렬되어 저장됨 ( innoDB는 클러스터링 테이블이 디폴트) ⇒ 프라이머리 키값 자체가 주소역할을 함
- 클러스터링이란 비슷한 값들은 최대한 모아서 저장하는 방식을 의미
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 컬럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 함. innoDB 테이블에서는 프라이머리 키 값 자체가 주소역할을 하기 때문에 인덱스는 항상 인덱스 칼럼값과 주소값(프라이머리 키값)의 조합으로 구성됨

### 5.3.2 B-Tree 인덱스 키 추가 및 삭제

**인덱스 키 추가** 

- InnoDB에서는 Buffer Pool과 Insert Buffer를 이용해서 인덱스 키 추가작업을 지능적으로 처리함
    - Buffer Pool : 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간. 쓰기 작업을 지연시켜 일괄작업으로 처리해주는 버퍼역할도 같이 함
    - Insert Buffer : 레코드가 추가/변경되면 인덱스 또한 업데이트 되어야 하는데, 인덱스를 업데이트 하는 작업은 랜덤하게 디스크를 읽는 작업이 필요하기 때문에 테이블에 인덱스가 많다면 이 작업은 많은 자원을 소모함. InnoDB는 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하지만 버퍼풀에 없고 디스크로부터 읽어와서 업데이트 해야 한다면 이를 즉시 실행하지 않고 임시 공간에 저장만 해둔 후에 사용자에게는 결과를 먼저 반환하는 형태로 성능을 향상함. 이때 사용하는 메모리 공간을 Insert Buffer라고 함 
    (단, 사용자에게 전달하기 전 반드시 중복 여부를 체크해야 하는 유니크 인덱스는 인서트 버퍼 사용 불가)
    - Insert Buffer Merge Thread : 인서트 버퍼에 임시로 저장되어 있는 인덱스 레코드 조각은 이후 백그라운드 스레드에 의해 병합되는데, 이 스레드를 인서트 버퍼 머지 스레드라고 함
- MySQL 5.5 이상부터 인덱스 키의 추가 및 삭제 작업까지 버퍼링해서 지연 처리할 수 있게 기능이 확장됨 (Insert Buffering 에서 Change Buffering으로 네이밍 변경됨)

![No image](/assets/posts/20210424/buffer.png)

(1) 사용자의 쿼리 실행

(2) 버퍼 풀에 새로운 키값을 추가해야할 페이지(B-Tree의 리프노드)가 존재한다면 즉시 키 추가 작업 처리

(3) 버퍼 풀에 B-Tree의 리프노드가 없다면 인서트 버퍼에 추가할 키값과 레코드의 주소를 임시로 기록해두고 작업완료 (사용자의 쿼리 실행 완료됨)

(4) 백그라운드 작업으로 인덱스 페이지를 읽을때마다 인서트 버퍼에 머지해야할 인덱스 키 값이 있는지 확인한 후, 있다면 병합함 (B-Tree에 인덱스 키와 주소를 저장)

(5) 데이터베이스 서버 자원의 여유가 생기면 MySQL 서버의 인서트 버퍼 머지 스레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 주소 값을 머지 (B-Tree에 인덱스 키와 주소를 저장)

**인덱스 키 삭제** 

- B-Tree의 키 값 삭제는, 해당 키값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제마크만 하면 작업이 완료됨. 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용할 수 있음
- 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하지만, MySQL 5.5이상의 InnoDB 스토리지 엔진에서는 이 작업 또한 버퍼링되어 지연처리 시킬 수 있음 (처리지연이 없다면 키 삭제가 완료되어야 쿼리 실행이 완료됨)
- 처리가 지연된 인덱스 키 삭제는 MySQL 서버가 내부적으로 처리하므로 특별히 걱정할 필요 없음

**인덱스 키 변경**

- 인덱스의 키 값은 그 값에 따라 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우, 단순히 인덱스 상의 키 값만 변경하는 것은 불가능
- B-Tree의 키값 변경 작업은 키값을 삭제한 후, 다시 새로운 키 값을 추가하는 형태로 처리됨. 앞서 설명한 삭제/추가 절차대로 진행됨

**인덱스 키 검색**

- 인덱스를 검색하는 작업은 B-Tree의 루트 노드부터 시작해 브랜치 노드를 거쳐 최종 리프노드 까지 이동하면서 비교작업을 수행(트리 탐색)
- SELECT에서만이 아닌 UPDATE, DELETE 처리를 위해 해당 레코드를 먼저 검색해야 할 경우에도 인덱스가 있으면 빠른 검색이 가능
- UPDATE, DELETE 문장이 실행될 때 테이블에 적당한 인덱스가 없으면, 불필요하게 많은 레코드를 잠그게 됨 (InnoDB에서는 레코드 자체가 아닌, 인덱스의 레코드 모두를 잠그는데 인덱스가 없으면 row를 다 잠궈버림)
- B-Tree 인덱스를 이용한 검색은 100%일치 또는 값의 앞부분(Left-most part. like 'AA%')만 일치하는 경우에 사용 가능
- not equal(<>) 비교나 값의 뒷부분(like '%AA')이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색이 불가능. 또한 인덱스의 키 값이 변형된 후 비교되는 경우, 변형된 값은 B-Tree 인덱스에 존재하는 값이 아니기 때문에 B-Tree의 빠른 검색을 이용할 수 없음

### 5.3.3 B-Tree 인덱스 사용에 영향을 미치는 요소

**인덱스 키값의 크기**

- InnoDB 스토리지 엔진에서는 페이지(또는 블록) 단위로 데이터를 저장하고, 인덱스 또한 페이지 단위로 관리됨 (B-Tree에서 각 노드를 구분한 기준이 페이지 단위)
- B-Tree는 각 노드가 2개의 자식노드만 갖는 Binary Tree가 아니라 자식 노드의 개수가 가변적인 Balanced Tree를 뜻함
- B-Tree가 자식노드를 몇 개까지 가질 수 있는지는 인덱스의 페이지 크기와 키 값의 크기에 따라 결정됨
- InnoDB의 모든 페이지 크기는 16KB로 고정되어 있음
- 자식 노드 주소는 여러가지 복합적인 정보가 담긴 영역이며 페이지 종류별로 대략 6~12바이트 까지 다양한 크기 값을 가질 수 있음
- 인덱스 키가 16바이트이고 자식노드주소가 12바이트로 구성되어 있다고 가정하면 인덱스 페이지는 아래와 같은 형태로 구성

![No image](/assets/posts/20210424/indexByte.png)

- 하나의 인덱스 페이지가 16KB 이므로, 계산해보면 하나의 인덱스페이지에 16*1024 / (16+12) = 585개의 인덱스 저장이 가능하고, 최종적으로 이 노드의 경우 자식노드를 585개 까지 가질 수 있는 B-Tree가 되는 것이다.

`만약 인덱스의 키 값이 커지면 ?`

- 위의 경우에서 인덱스의 키 값이 16바이트에서 32바이트로 늘어났다고 가정하면, 한 페이지에 인덱스 키를 16*1024/(32+12) = 372개만 저장이 가능
- 만약 SELECT 쿼리가 레코드 500개를 읽어야 한다면 인덱스 키가 16바이트인 경우에는 인덱스 페이지 한번으로 해결 될 수 도 있지만, 32바이트인 경우에는 최소 2번 이상 디스크로부터 읽어야 함
- 인덱스 크기가 커지면 디스크로부터 읽는 횟수가 증가로 성능저하 발생
- 또한 인덱스 키 값의 크기가 커지면 버퍼 풀 메모리에 캐시해 둘 수 있는 인덱스 레코드가 줄어들기 때문에 자연히 메모리 효율이 떨어지게 됨

**선택도(기수성 = Cardinality)**

- 인덱스에서 선택도(Selectivity) 또는 기수성(Cardinality)은 거의 같은 의미로 사용되며, 모든 인덱스 키값 가운데 유니크한 값의 수를 의미
- 전체 인덱스 키값은 100개인데, 그 중에서 유니크한 값의 수는 10개라면 기수성은 10 이다.
- 인덱스 키값 가운데 중복된 값이 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어짐. 인덱스는 선택도가 높을 수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리됨
- `선택도가 좋지 않다고 하더라도 정렬이나 그룹핑과 같은 작업을 위해 인덱스를 만드는 것이 훨씬 나은 경우도 많다. 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다.`

```sql
CREATE TABLE tb_city(
	country VARCHAR(10),
	city VARCHAR(10),
	INDEX ix_country (country)
);

# tb_city 테이블에 1만건의 레코드가 저장되어 있고,
# tb_city 테이블에 국가와 도시가 중복되서 저장되지 않는다고 가정

SELECT * FROM tb_city WHERE country='KOREA' AND city='SEOUL';
```

- country 컬럼의 유니크 값이 10개일 때
    - MySQL 서버는 인덱스된 컬럼(country)에 대해서는 전체 레코드가 몇건이며, 유니크한 값의 개수 등에 대한 통계정보를 가지고 있음. 전체 레코드 건수를 유니크한 값의 개수로 나눠보면 하나의 키 값으로 검색했을 때 대략 몇건의 레코드가 일치할 지 예측할 수 있게 됨
    - "country='KOREA'" 라는 조건으로 인덱스를 검색하면 대략 1000건 (10,000/10) 일 것을 예상할 수 있음
    - 그런데 인덱스를 통해 검색된 1000건 중 city='SEOUL'인 레코드는 1건이므로 999건은 불필요하게 읽은 것으로 볼 수 있음
- country 컬럼의 유니크 값이 1000개 일 때
    - "country='KOREA'" 라는 조건으로 인덱스를 검색하면 대략 10건 (10,000/1,000) 일 것을 예상할 수 있음
    - 인덱스를 통해 검색된 10건 중 city='SEOUL'인 레코드는 1건이므로 9건은 불필요하게 읽은 것으로 볼 수 있음
    - 2가지 케이스를 비교해봤듯이, 같은 쿼리를 실행하더라도 인덱스의 유니크한 값의 개수는 효율성에 큰 영향을 미침

**읽어야 하는 레코드의 건수**

- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다
- 테이블에 레코드가 100만 건이 저장되어 있고, 그중에서 50만건을 읽어야 하는 쿼리가 있을때 전체 테이블을 모두 읽어서 필요 없는 50만 건을 버리는 것이 효율적일지? 인덱스를 통해 필요한 50만 건만 읽어오는 것이 효율적일지 ?
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 더 비용이 많이 드는 작업인 것으로 예측함
- 즉, 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 필터링하는 방식으로 처리하는 것이 효율적
- `100만 건의 레코드 가운데 50만 건을 읽어야 하는 작업은, 인덱스의 손익분기점인 20~25%보다 훨씬 크기 때문에 MySQL옵티마이저는 인덱스를 이용하지 않고 직접 테이블을 전부 읽는 방식으로 처리할 것이다`

### 5.3.4 B-Tree 인덱스를 통한 데이터 읽기

**인덱스 레인지 스캔 방식**

![No image](/assets/posts/20210424/indexRangeScan.png)

```sql
SELECT * FROM employees WHERE first_name BETWEEN 'Ebbe' AND 'Gad';
```

- 인덱스 레인지 스캔은 인덱스의 접근 방법 가운데 가장 대표적인 방식으로 검색해야 할 인덱스 범위가 결정됐을 때 사용하는 방식
- 루트 노드에서부터 비교를 시작해 브랜치노드를 거쳐 최종적으로 리프노드에서 원하는 시작지점을 찾을 수 있음. 그때부터 리프노드의 레코드만 순서대로 읽으면 됨
- 리프노드의 시작점을 파악한 후, 그 지점부터 해당 인덱스를 구성하는 칼럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져옴. 이는 별도의 정렬 과정이 수반되는 것이 아니라 인덱스 자체의 정렬 특성 때문에 자동으로 그렇게 동작함
- 리프 노드의 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한건 한건 단위로 랜덤 I/O가 한번씩 실행됨
- 랜덤I/O가 많이 발생하기 때문에 인덱스를 통한 데이터 레코드를 읽는 작업이 비용이 많이 드는 것이고, 그래서 읽어야할 데이터 레코드가 20~25%가 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 되는 것임

**인덱스 풀 스캔**

![No image](/assets/posts/20210424/indexFullScan.png)

- 인덱스 레인지 스캔과 다른 점은 인덱스의 처음부터 끝까지 모두 읽는 방식
- 그림처럼 먼저 인덱스 리프노드의 제일 앞 또는 제일 뒤로 이동 후, 인덱스의 리프노드를 연결하는 링크드 리스트를 따라서 처음부터 끝까지 스캔하는 방식
- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫 번째 컬럼이 아닌 경우 인덱스 풀 스캔 방식이 사용됨. 예를 들어 인덱스가 (A, B, C) 컬럼의 순서대로 만들어져 있지만 쿼리의 조건절은 B컬럼이나 C컬럼으로 검색하는 경우.
- 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우 이 방식이 사용되며, 인덱스 뿐만 아니라 데이터 레코드까지 모두 읽어야 한다면 이 방식으로 처리되지 않음
- 인덱스의 크기는 테이블의 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적

**루스(Loose) 인덱스 스캔**

![No image](/assets/posts/20210424/looseIndexScan.png)

- 인덱스 레인지 스캔과 비슷하게 작동하지만, 중간마다 필요치 않은 인덱스 키값은 SKIP하고 다음으로 넘어가는 형태로 처리 (MySQL에서의 루스 인덱스 스캔 기능은 아직 제한적임)
- 오라클 DBMS의 인덱스 스킵 스캔이라고 하는 기능과 작동 방식이 비슷함
- 일반적으로 GROUP BY 또는 집합 함수 가운데 MAX(), MIN() 함수에 대해 최적화를 하는 경우에 사용됨

```sql
SELECT dept_no, MIN(emp_no)
FROM dept_emp
WHERE dep_no BETWEEN 'd002' AND 'd004'
GROUP BY dept_no;
```

- dept_emp 테이블은 (dept_no , emp_no) 두 개의 컬럼으로 인덱스가 생성된 상태
- dept_no + emp_no 값으로 정렬되어 있는 상태이기 때문에, 그림에서처럼 dept_no 그룹별로 제일  첫 번째 레코드의 emp_no 값만 읽으면 됨
- 즉, 인덱스에서 WHERE 조건을 만족하는 범위 전체를 다 스캔할 필요가 없다는 것을 옵티마이저가 알기 때문에 조건에 만족하지 않는 레코드는 무시하고 다음 레코드로 이동함

### 5.3.5 다중 칼럼(Multi-column) 인덱스

![No image](/assets/posts/20210424/multiColumnIndex.png)

- 2개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 하며, 2개 이상의 칼럼이 연결됐다고 해서 Concatenated Index 라고도 함
- 인덱스의 두번째 칼럼은 첫번째 칼럼에 의존해서 정렬됨. 즉, 두번째 칼럼의 정렬은 첫번째 칼럼이 똑같은 레코드에서만 의미가 있다. (N번째 칼럼은 N-1번째 칼럼에 의존해서 정렬됨)
- 그림에서처럼 emp_no(두번째 칼럼) 값의 정렬 순서가 빠르다 하더라도 dept_no 칼럼의 정렬 순서가 늦다면 인덱스의 뒤쪽에 위치함
- 따라서 다중 칼럼 인덱스에서는 인덱스 내의 각 칼럼의 위치가 상당히 중요

### 5.3.6 B-Tree 인덱스의 정렬 및 스캔 방향

- 인덱스의 키 값은 항상 오름차순으로 정렬되지만, 사실 그 인덱스를 거꾸로 읽으면 내림차순으로 정렬된 인덱스로도 사용 가능
- 인덱스를 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어내는 실행계획에 따라 결정됨

**인덱스의 정렬**

- MySQL에서 인덱스는 모든 칼럼이 오름차순으로만 정렬된다. 인덱스 생성시에 ASC, DESC 키워드를 사용은 가능하지만 앞으로 만들어질 호환성을 위해 문법상으로만 제공하는 것이고 항상 오름차순으로만 생성됨
- 인덱스를 거꾸로 읽으면 내림차순으로 읽을 수 있기 때문에 큰 문제는 되지 않음
- 하지만 다중 칼럼 인덱스에서 오름차순 칼럼과 내림차순 칼럼을 혼합해서 만들어야할 때가 있음. 이런 경우 칼럼의 값을 역으로 변환해서 (ex 양수를 음수로) 저장하는 방식을 사용할 수 밖에 없음
- `MySQL 8.x 버전부터 innoDB 엔진만 내림차순 인덱스 지원함`
> 8.3.13 Descending Indexes
MySQL supports descending indexes: DESC in an index definition is no longer ignored but causes storage of key values in descending order. Previously, indexes could be scanned in reverse order but at a performance penalty. A descending index can be scanned in forward order, which is more efficient. Descending indexes also make it possible for the optimizer to use multiple-column indexes when the most efficient scan order mixes ascending order for some columns and descending order for others.
> [https://dev.mysql.com/doc/refman/8.0/en/descending-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/descending-indexes.html)

### 5.3.7 B-Tree 인덱스의 가용성과 효율성

**비교 조건의 종류와 효율성**

- 다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등비교인지, 범위조건인지에 따라 인덱스의 활용형태와 효율이 달라진다

```sql
SELECT * FROM dept_emp
WHERE dept_no='d002' AND emp_no >= 10144;
```

![No image](/assets/posts/20210424/indexScanCase.png)

case A : 첨부사진 왼쪽) 인덱스 dept_no + emp_no

- 이 경우 dept_no = 'd002' AND emp_no ≥ 10144 인 레코드를 찾고, 그 이후에 dept_no가 'd002'가 아닐 때까지 인덱스를 쭉 읽기만 하면 됨.
- 이 경우 모든 읽어들인 레코드 모두가 사용자가 원하는 결과임을 알 수 있음. 즉, 5건의 레코드를 찾는데 꼭 필요한 5번의 비교작업만 수행했기 때문에 상당히 효율적으로 인덱스 이용
- 인덱스의 두번째 칼럼(emp_no)이 비교작업의 범위를 줄이는 역할을 함 (= 작업 범위 결정 조건)

case B : 첨부사진 오른쪽) 인덱스 emp_no + dept_no

- 이 경우, emp_no ≥ 10144 AND dept_no='d002' 인 레코드를 찾고, 그 이후에 모든 레코드에 대해 dept_no='d002' 인지 비교하는 과정을 거쳐야 함 (필터링 작업)
- 이 경우에는 5건의 레코드를 찾기 위해 7번의 비교과정을 거침
- 인덱스의 두번째 칼럼(dept_no)이 비교 작업의 범위를 좁히는데 도움을 주지 못하고, 단지 쿼리의 조건에 맞는지 검사하는 용도로만 사용됨 (= 필터링 조건)

결론 

- 작업 범위 결정 조건은 많을수록 쿼리의 처리 성능을 높이지만, 필터링 조건은 최종적으로 가져오는 레코드는 작게 만들지 몰라도, 필터링 조건이 많다고 해서 쿼리의 처리 성능을 높이지는 못함

**인덱스의 가용성**

- B-Tree 인덱스의 특징은 왼쪽 값에 기준(Left-most)해서 오른쪽 값이 정렬됨

```sql
# index(first_name) 설정
# first_name 칼럼에 저장된 값의 왼쪽부터 한글자씩 비교해가면서 일치하는 레코드를 찾아야 함.
# 조건절에 주어진 상수 값은 왼쪽부분이 고정되어 있지 않음.
# 이 쿼리는 인덱스 레인지 스캔 방식 사용 불가. 
SELECT * FROM employees WHERE first_name LIKE '%mer';

# index(dept_no, emp_no) 설정
# dept_no 값 없이 emp_no 값으로만 검색하면 인덱스를 효율적으로 사용할 수 없음.
# dept_no 에 대해 먼저 정렬한 후, 다시 emp_no 칼럼으로 정렬되기 때문.
# 작업 범위 결정 조건으로 인덱스를 사용할 수 없지만, 필터링 조건으로 인덱스를 사용
SELECT * FROM dept_emp WHERE emp_no >= 10144;
```

**가용성과 효율성 판단**

- 다음과 같은 경우는 인덱스로 사용 불가 (사용할 수 없다는 것은 작업 범위 결정조건으로 사용할 수 없다는 것을 의미하며, 경우에 따라서는 필터링 조건으로는 사용 가능)

`NOT-EQUAL로 비교된 경우("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")`

> 다른 일반적인 DBMS에서 NULL 값은 인덱스에 저장되지 않지만, MySQL에서는 NULL 값도 인덱스로 관리된다. `WHERE column IS NULL` 조건도 작업 범위 결정 조건으로 인덱스를 사용한다.

```sql
WHERE column <> 'N'
WHERE column NOT IN (10, 11, 12)
WHERE column IS NOT NULL
```

`LIKE '%??' (앞부분이 아닌 뒷부분 일치) 형태로 문자열 패턴이 비교된 경우`

```sql
WHERE column LIKE '%paylater'
WHERE column LIKE '_paylater'
WHERE column LIKE '%paylater%'

# LIKE '_' => 무조건 character 1개만 일치
```

`스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우`

```sql
WHERE SUBSTRING(column, 1, 1) = 'X'
WHERE DAYOFMONTH(column) = 1
```

`NOT-DETERMINISTIC 속성의 스토어드 함수가 비교 조건에 사용된 경우`

```sql
WHERE column = deterministic_function()
# 스토어드 함수는 11장에서 진행
# 스토어드 함수가 NOT-DETERMINISTIC 으로 정의되면, 
# 함수 호출시마다 결과값이 달라진다고 가정하고 비교가 실행되는 레코드마다 함수 호출함
```

`데이터 타입이 서로 다른 비교(인덱스 칼럼의 타입을 변환해야 비교가 가능한 경우)`

```sql
WHERE char_column=10
```

`문자열 데이터 타입의 콜레이션이 다른 경우`

```sql
WHERE utf8_bin_char_column = euckr_bin_char_column
```

**인덱스가 다음과 같을 때 사용 예시**

`INDEX ix_test (column_1, column_2, column_3, ..., column_n)`

**작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우**

- column_1 칼럼에 대한 조건이 없는 경우
- column_1 칼럼의 비교 조건이 위에서 설명한 인덱스 사용 불가 조건 중 하나인 경우

**작업 범위 결정 조건으로 인덱스를 사용하는 경우(i는 2보다 크고 n보다 작은 임의의 값을 의미)**

- column_1 ~ column_(i-1) 칼럼까지 Equal 형태("=" 또는 "IN")로 비교
- column_i 칼럼에 대해 다음 연산자 중 하나로 비교
    - Equal("=" 또는 "IN")
    - 크다 작다 형태 (">" 또는 "<")
    - LIKE로 좌측 일치 패턴 (LIKE 'paylater%')
- 위 2가지 조건을 모두 만족하는 쿼리의 경우, column_1 부터 column_i 까지는 범위 결정 조건으로 사용되고, column_i 다음부터 column_n 까지의 조건은 필터링 조건으로 사용됨

```sql
# 인덱스 사용 불가 
WHERE column_1 <> 2

# column_1과 column2 까지 범위 결정 조건으로 사용됨
WHERE column_1 = 1 AND column_2 > 10

# column_1, column_2, column_3 까지 범위 결정 조건으로 사용됨 
WHERE column_1 IN (1, 2) AND column_2 = 2 AND column_3 <= 10

# column_1, column_2, column_3 까지는 범위 결정 조건으로, column_4는 필터링 조건으로 사용됨 
WHERE column_1 = 1 AND column_2 = 2 AND column_3 IN (10,20,30) AND column_4 <> 100

# column_1, column_2, column_3, column_4 까지 범위 결정 조건으로 사용됨
WHERE column_1 = 1 AND column_2 IN (2,4) AND column_3 = 30 AND column_4 LIKE 'paylater%'

# column_1, column_2, column_3, column_4, column_5 칼럼까지 범위 결정 조건으로 사용됨 
WHERE column_1 = 1 AND column_2 = 2 AND column_3 = 30 
		AND column_4 ='paylater' AND column_5 = 'naver'
```

## 5.4 해시(Hash) 인덱스

- 해시 인덱스는 동등 비교 검색에는 최적화되어 있지만 범위검색이나 정렬된 결과를 가져오는 목적으로는 사용할 수 없음
- 일반적인 DBMS에서 해시 인덱스는 메모리 기반의 테이블에 주로 구현되어 있으며 디스크 기반의 대용량 테이블용으로는 거의 사용되지 않음

### 5.4.1 구조 및 특성

![No image](/assets/posts/20210424/hashIndex.png)

- 해시 인덱스는 실제 키값이 아닌, 해시 함수의 결과를 저장하므로 키 값의 길이가 아무리 길어도 인덱스 크기가 작고 검색이 빠름
- 해시 인덱스는 트리구조가 아니므로 검색하고자 하는 값을 주면 해시 함수를 거쳐서 찾고자 하는 키값이 포함된 버켓을 알아낼 수 있음. 찾은 버켓 하나만 읽어서 비교해보면 실제 레코드가 저장된 위치를 바로 알 수 있음
- 해시 함수의 결과값의 범위가 좁으면 필요한 버켓의 개수가 줄지만 충돌이 많이 발생하기 때문에 필터링 과정이 추가로 필요하기 때문에 자연히 검색 성능이 느려짐
- 해시 인덱스를 지원하는 스토리지 엔진에는 이미 해시 함수를 내장하고 있고 모든 처리를 자동으로 해주기 때문에 실제 사용자가 해시함수를 생성할 필요는 없음

### 5.4.2 해시 인덱스의 가용성 및 효율성

- 해시 인덱스는 빠른 검색이 가능하지만 키값 자체가 변환되어 저장되기 때문에 범위 검색이나 원본값 기준 정렬이 불가능

**작업 범위 결정 조건으로 해시 인덱스를 사용하는 쿼리**

- 아래 쿼리는 해시 인덱스의 장점을 그대로 이용 가능

```sql
SELECT .. FROM tb_hash WHERE column = '검색어';
SELECT .. FROM tb_hash WHERE column <=> '검색어';
SELECT .. FROM tb_hash WHERE column IN ('검색어1', '검색어2');
SELECT .. FROM tb_hash WHERE column IS NULL;
SELECT .. FROM tb_hash WHERE column IS NOT NULL;
```

**해시 인덱스를 전혀 사용하지 못하는 쿼리**

- 아래 쿼리는 어떠한 방법으로도 해시 인덱스 사용 불가. 작업 범위 결정 조건 뿐만 아니라 필터링 조건으로도 전혀 사용할 수 없음
- 대체로 범위 비교나 부정형 비교는 해시인덱스 사용 불가

```sql
SELECT .. FROM tb_hash WHERE column >= '검색어';
SELECT .. FROM tb_hash WHERE column BETWEEN 100 AND 120;
SELECT .. FROM tb_hash WHERE column LIKE '검색어%';
SELECT .. FROM tb_hash WHERE column <> '검색어';
```

**다중 칼럼 해시 인덱스**

- 다중 컬럼으로 생성된 해시 인덱스도 모든 칼럼이 동등 조건으로 비교되는 경우에만 인덱스 사용 가능
- 아래 예시처럼 member_id만 동등 조건으로 비교되는 경우에는 인덱스 사용 불가

```sql
CREATE TABLE tb_session (
	session_id BIGINT NOT NULL,
	member_id CHAR(20) NOT NULL,
	...
	INDEX ix_memberid_sessionid (member_id, session_id) using HASH
) ENGINE=MEMORY;

SELECT * FROM tb_session WHERE member_id='user_nickname';
```

## 5.5 R-Tree 인덱스

- MySQL에는 2차원의 데이터를 인덱싱하고 검색하는 목적의 공간 인덱스라는 것이 있는데, 이 공간 인덱스는 R-Tree 알고리즘을 이용함
- GPS나 GIS 기반의 위치 기반 서비스를 구현할 때 MySQL의 공간 확장 (Spatial Extension)을 이용할 수 있음
- *공간 검색에 대해서는 8장에서 다룸*

### 5.5.1 구조 및 특성

- MySQL은 공간 정보의 저장 및 검색을 위해 여러가지 기하학적 도형(Geometry) 정보를 관리할 수 있는 데이터 타입을 제공함

![No image](/assets/posts/20210424/Rtree.png)

- 공간 정보 검색을 위한 R-Tree 알고리즘을 이해하려면 MBR 개념을 이해해야 함
- MBR(Minimum Bounding Rectangle) : 해당 도형을 감싸는 최소 크기의 사각형을 의미 (사진속 빨간색 테두리가 MBR을 의미)
- 이 사각형들의 포함 관계를 B-Tree 형태로 구현한 인덱스가 R-Tree 인덱스

![No image](/assets/posts/20210424/Rtree2.png)

- 도형의 MBR을 그려보면, 그림에서 가장 최상위 MBR(T, U)는 R-Tree의 루트 노드에 저장
- 최하위 레벨의 MBR(각 도형을 제일 안쪽에서 둘러싼 사각형)은 R-Tree의 리프 노드에 저장됨

### 5.5.2 R-Tree 인덱스의 용도

- R-Tree는 MBR 정보를 이용해 B-Tree 형태로 인덱스를 구축하므로, Rectangle + B-Tree 를 섞어서 R-Tree 라고 이름이 지어졌으며, 공간 인덱스라고도 함
- 일반적으로 좌표 시스템에 기반을 둔 정보에 대해 저장할 때 사용
- R-Tree는 각 도형(=도형의 MBR)의 포함 관계를 이용해 만들어진 인덱스기 때문에 Contains(), Intersect() 등과 같은 포함관계를 비교하는 함수로 검색할때 인덱스 이용이 가능

![No image](/assets/posts/20210424/Rtree3.png)

- 그림에서 가운데 위치한 P가 기준점이고, 기준점으로부터 반경 5km 이내의 점들을 검색하려면 우선 사각상자안에 포함되는 점들을 검색 (Contains 또는 Intersect 함수 이용)
- 여기서 Contains()나 Intersect() 연산은 사각형 박스와 같은 다각형(Polygon)으로만 연산할 수 있으므로 반경 5km를 그리는 원을 포함하는 최소 사각형으로 포함 관계 비교를 수행한 것이다. 즉, 연산결과에는 원 밖에 있지만 사각형 안에 있는 P6이 포함된 결과를 나타냄

```sql
# 공간좌표 Px 가 사각 상자에 포함되는지 비교
SELECT * FROM tb_location
WHERE CONTAINS(px, 사각상자);
```

## 5.6 Fractal-Tree 인덱스

- **SKIP**
- Fractal-Tree는 독점적인 특허로 등록된 알고리즘인데, 현재 TokuTek 회사에서 개발된 MySQL의 스토리지 엔진인 TokuDB 에만 적용되어 있음
- B-Tree 인덱스의 단점은 인덱스 키를 검색하거나 변경하는 과정에서 디스크의 랜덤I/O 가 상대적으로 많이 필요함.
- Fractal Tree는 이러한 B-Tree의 단점을 최소화하고 "Big I/O"에 초점을 맞춘 자료 구조로, 잦은 Disk I/O를 줄이고, 한번에 대량의 데이터를 하단 노드로 전달함에 따라 데이터가 많은 상황에서도 효과적으로 처리할 수 있는 방안을 제시
- [https://gywn.net/2014/05/fractal-index-in-tokudb/](https://gywn.net/2014/05/fractal-index-in-tokudb/)

## 5.7 전문 검색(Full Text search) 인덱스

- B-Tree 인덱스는 전체 일치 또는 좌측 일부 일치와 같은 검색만 가능
- 문서내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문검색에는 B-Tree인덱스 사용불가
- 전문 검색 인덱스는 일반화된 기능의 명칭이지 알고리즘의 이름을 지칭하는 것은 아님. 인덱싱하는 기법에 따라 구분자(Stopword)와 N-그램 방식으로 나뉨

### 5.7.1 인덱스 알고리즘

**구분자(Stopword) 기법**

- 전문의 내용을 공백이나 탭 또는 마침표와 같은 문장 기호, 그리고 사용자가 정의한 문자열을 구분자로 등록한 후, 이 구분자를 이용해 키워드를 분석해내고 결과 단어를 인덱스로 생성해 두고 검색에 이용하는 방법
- MySQL의 내장 전문 검색 엔진은 구분자 방식으로만 인덱싱이 가능
- 구분자 기법은 문서의 본문으로부터 키워드를 추출해 내는 작업이 추가로 필요할 뿐, 내부적으로는 B-Tree 인덱스를 그대로 사용
- 전문 검색 인덱스의 많은 부분은 B-Tree의 특성을 따르지만 전문 검색 엔진을 통해 조회되는 레코드는 검색어나 본문 내용으로 정렬되어 조회되지 않음
- 전문 검색에서 결과의 정렬은 일치율이 높은 순으로 출력

**N-그램(n-Gram) 기법**

- 다양한 국가의 언어에 대해 하나의 규칙을 적용해 키워드를 추출하기 어렵고, 구분자 방식은 추출된 키워드의 일부(키워드의 뒷부분)만 검색하는 것은 불가능
- N-그램은 이런 단점을 보완하여 본문을 무조건적으로 몇 글자씩 잘라서 인덱싱하는 방법으로, 구분자에 의한 방법보다는 인덱싱 알고리즘이 복잡하고 만들어진 인덱스의 크기도 상당히 큰 편
- N-그램의 n은 인덱싱할 키워드의 최소 글자(또는 바이트)수를 의미하는데 일반적으로 2글자 단위로 키워드를 쪼개서 인덱싱하는 2-Gram(또는 Bi-Gram) 방식이 많이 사용됨
- 서드파티에서 제공하는 플러그인

**2-Gram 인덱싱**

- 2글자 단위의 최소 키워드에 대한 키를 관리하는 프론트엔드(Front-end) 인덱스와, 2글자 이상의 키워드 묶음(n-SubSequence Window)을 관리하는 백엔드(Back-end) 인덱스 2개로 구성

![No image](/assets/posts/20210424/2Gram.png)

- 첫번째 단계로 문서의 본문을 2글자보다 큰 크기로 블록을 구분해서 백엔드 인덱스(3) 생성
- 두번째 단계로 백엔드 인덱스의 키워드들을 2글자씩 잘라서 프론트엔드 인덱스(6) 생성
- 최종적으로 3번,6번 표는 정규화 과정을 거쳐 B-Tree 알고리즘으로 인덱싱 됨
- 인덱스의 검색 과정은 전문 인덱스의 생성과는 반대로 입력된 검색어를 2바이트 단위로 동일하게 잘라서 프론트엔드 인덱스를 검색하고, 그 결과를 대상 후보 군으로 선정한 후 백엔드 인덱스를 통해 최종 검증을 거쳐 일치하는 결과를 가져옴

### 5.7.2 구분자와 N-그램의 차이

- 실제 사용자가 보는 구분자와 N-그램의 차이는 검색 결과에 있음

```sql
CREATE TABLE tb_test (
	doc_id INT,
	doc_body TEXT,
	PRIMARY KEY (doc_id),
	FULLTEXT KEY fx_docbody (doc_body)
);
```

![No image](/assets/posts/20210424/fulltext1.png)

```sql
SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST('아이폰' IN BOOLEAN MODE);
```

![No image](/assets/posts/20210424/fulltext2.png)

- 구분자 방식과 N-Gram 방식에 따라 결과가 다르게 나타남
- 구분자 방식의 검색에서는 반드시 구분자를 기준으로 삼아 왼쪽 일치 기준으로 비교 검색을 실행. 그래서 검색어("아이폰") 앞에 다른 단어("애플")가 연결되어 있으면 찾아낼 수 없음
- N-Gram은 모든 데이터에 대해 무작위로 2바이트씩 인덱스를 생성하므로 검색이 가능

### 5.7.3 전문 검색 인덱스의 가용성

- `SELECT * FROM tb_test WHERE doc_body LIKE '%아이폰%';`  같은 쿼리로도 원하는 검색 결과를 얻을 수 있다. 하지만 이 방식은 전문 검색 인덱스를 이용해 효율적으로 쿼리가 실행된 것이 아닌 풀 테이블 스캔으로 쿼리를 처리한다.
- 전문 검색 인덱스를 사용하려면 반드시 `MATCH(...) AGAINST(...)` 구문으로 검색 쿼리를 작성해야 하며, MATCH 절의 괄호에 포함되는 내용은 반드시 사용할 전문 검색 인덱스에 정의된 칼럼이 모두 명시되어야 한다.

## 5.8 비트맵 인덱스와 함수 기반 인덱스

- MySQL 스토리지 엔진 가운데 비트맵 인덱스와 함수 기반 인덱스를 지원하는 스토리지 엔진은 없음
- 비트맵 인덱스에 대한 대안은 없지만 함수 기반 인덱스는 우회해서 구현 가능
- 테이블에 함수의 결과 값을 저장하기 위한 칼럼을 추가하고, 그 칼럼에 인덱스를 생성하면 인덱스 사용 가능
- 상당히 길이가 긴 칼럼에 대한 동등 비교 검색을 위해 문자열의 해시값을 생성해서 별도의 칼럼에 저장하고 해당 칼럼에 인덱스를 생성하는 방식을 사용하기도 함
- 참고로 InnoDB에서 인덱스는 하나의 레코드가 767바이트 이상을 넘을 수 없음. 이때는 칼럼의 앞 부분 767 바이트만 잘라서 인덱스 키로 사용됨

## 5.9 클러스터링 인덱스

- 인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것
- MySQL에서 클러스터링 인덱스는 InnoDB와 TokuDB 스토리지 엔진에서만 지원

### 5.9.1 클러스터링 인덱스

- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되기 때문에, 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현함
- 즉, 프라이머리 키값에 의해 레코드의 저장 위치가 결정되는 것을 의미하며, 이는 프라이머리 키값이 변경된다면 그 레코드의 물리적인 저장위치가 바뀌어야 한다는 것을 의미하기도 함
- 클러스터링 인덱스는 사실 인덱스 알고리즘이라기보다 테이블 레코드의 저장방식이라고 볼 수 있기 때문에 `클러스터링 인덱스`와 `클러스터 테이블`은 동의어로 사용되기도 함. 또한 클러스터링의 기준이 되는 프라이머리 키는 `클러스터 키` 라고 표현함
> 일반적으로 B-Tree 인덱스도 키값으로 이미 정렬되어 저장되지만, 이런 일반적인 B-Tree 인덱스를 클러스터링 인덱스라고 부르지 않는다. 테이블의 레코드가 프라이머리 키값으로 정렬되어 저장된 경우만을 "클러스터링 인덱스" 또는 "클러스터링 테이블"이라고 한다.

![No image](/assets/posts/20210424/clusterIndex1.png)

- 일반 B-Tree 인덱스의 경우, 리프 노드에는 실제 데이터 레코드를 찾아가기 위한 주소 값을 가지고 있음
- 클러스터링 인덱스의 경우, 리프 노드에 레코드의 모든 칼럼이 같이 저장되어 있음

![No image](/assets/posts/20210424/clusterIndex2.png)

- `UPDATE tb_test SET emp_no=10002 WHERE emp_no=10007;`
- 그럴 일은 없겠지만, 만약 클러스터 테이블에서 프라이머리 키를 변경하는 문장이 실행되면 위와 같이 레코드의 물리적인 저장 위치가 변경되기 때문에 프라이머리 키의 변경은 성능에 영향을 줄 수 있음 (레코드를 DELETE 하고 INSERT 하는 작업 필요)
> MyISAM 테이블이나 InnoDB를 제외한 기타 테이블의 데이터 레코드는 프라이머리 키나 인덱스 키값이 변경된다고 해서 실제 데이터 레코드의 위치가 변경되지 않는다. 데이터 레코드가 INSERT될 때 데이터 파일의 끝에(또는 임의의 빈 공간)에 저장된다. 이렇게 한번 결정된 위치는 절대 바뀌지 않고, 레코드가 저장된 주소는 MySQL 내부적으로 레코드를 식별하는 아이디로 인식된다. 레코드가 저장된 주소를 ROW-ID 라고 표현하며, 일부 DBMS에서는 이 값을 사용자가 직접 조회하거나 쿼리의 조건으로 사용할 수 있지만 MySQL에서는 사용자에게 노출되지 않는다.

**프라이머리 키가 없는 InnoDB 에서의 클러스터 테이블**

- 프라이머리 키가 없는 경우 InnoDB 스토리지 엔진이 다음 우선순위대로 프라이머리 키를 대체할 칼럼을 선택

```
1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터 키로 선택
2. NOT NULL 옵션의 Unique Index 중에서 첫 번째 인덱스를 클러스터 키로 선택
3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가한 후, 클러스터 키로 선택
```

- InnoDB 엔진이 자동증가칼럼을 추가한 경우, 이 칼럼은 사용자에게 노출되지 않고 쿼리 문장에서도 명시적으로 사용 불가. 이는 아무 의미 없는 숫자값으로 클러스터링 되고 있는 것이며 아무런 혜택을 주지 않기 때문에 가능하다면 프라이머리 키를 명시하는 것이 유익

### 5.9.2 보조 인덱스(Secondary index)에 미치는 영향

- MyISAM , MEMORY 테이블 같은 클러스터링 되지 않은 테이블은 한번 저장된 공간에서 절대 이동하지 않기 때문에 프라이머리키와 보조 인덱스는 구조적으로 아무런 차이가 없음
- InnoDB의 경우, 만약 보조 인덱스가 실제 레코드의 저장된 주소를 가지고 있다면 클러스터 키값이 변경될 때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주소 값을 변경해야 함
- **이런 번거로움을 방지하고자 InnoDB 테이블(클러스터 테이블)의 모든 보조 인덱스는 해당 레코드의 주소가 아니라 프라이머리 키값을 저장하도록 구현되어 있음**

```sql
CREATE TABLE employees (
	emp_no INT NOT NULL,
	first_name VARCHAR(20) NOT NULL,
	PRIMARY KEY (emp_no),
	INDEX ix_firstname (first_name)
);

SELECT * FROM employees WHERE first_name='Aamer';
```

- 위의 employees 테이블에서 클러스터링된 InnoDB와 그렇지 않은 MyISAM의 처리과정 비교
- MyISAM
    - ix_firstname 인덱스를 검색해서 레코드의 주소를 확인
    - 레코드의 주소를 이용해 최종 레코드를 가져옴
- InnoDB
    - ix_firstname 인덱스를 검색해서 레코드의 프라이머리 키값을 확인
    - 프라이머리 키값을 이용해 다시 한번 테이블을 검색한 후 최종 레코드를 가져옴
    - InnoDB가 조금 더 복잡하게 처리되긴 하지만, InnoDB 테이블에서 프라이머리 키로 레코드를 읽는 과정은 매우 빠르게 처리되므로 성능을 걱정할 필요없음

### 5.9.3 클러스터 인덱스의 장점과 단점

**장점**

- 프라이머리 키(클러스터 키)로 검색할 때 처리 성능이 매우 빠름(특히, 프라이머리 키를 범위 검색하는 경우 매우 빠름)
- 테이블의 모든 보조 인덱스가 프라이머리 키를 가지고 있기 때문에 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)

**단점**

- 테이블의 모든 보조 인덱스가 클러스터 키를 갖기 때문에 클러스터 키값의 크기가 클 경우 전체적으로 인덱스의 크기가 커짐
- 보조 인덱스를 통해 검색할 때 프라이머리 키로 다시 한번 검색해야하므로 처리 성능이 조금 느림
- INSERT할 때 프라이머리 키에 의해 레코드의 저장 위치가 결정되기 때문에 처리 성능이 느림
- 프라이머리 키를 변경할 때 레코드를 DELETE하고 INSERT하는 작업이 필요하기 때문에 처리 성능이 느림

### 5.9.4 클러스터 테이블 사용 시 주의사항

**클러스터 인덱스 키의 크기**

- 클러스터 테이블의 경우, 모든 보조 인덱스가 프라이머리 키(클러스터 키)값을 포함하기 때문에 프라이머리 키의 크기가 커지면 보조 인덱스도 크기가 커짐
- 인덱스의 크기가 커질 수록 메모리가 많이 필요해짐

**프라이머리 키는 AUTO-INCREMENT 보다는 업무적인 칼럼으로 생성할 것(가능한 경우)**

- 프라이머리 키값에 의해 레코드의 위치가 결정되고, 프라이머리 키로 검색하는 경우 매우 빠르게 처리됨
- 따라서 업무적인 칼럼의 크기가 크더라도 업무적으로 해당 레코드를 대표할 수 있다면 그 칼럼을 프라이머리 키로 설정하는 것이 좋다

**프라이머리 키는 반드시 명시할 것**

- AUTO-INCREMENT 칼럼이라도 프라이머리 키는 설정하라. 그렇지 않으면 내부적으로 AUTO-INCREMENT 같은 자동 증가 칼럼을 추가해서 클러스터 키로 사용하는데, 이왕이면 사용자가 사용할 수 있는 값을 직접 프라이머리 키로 설정하는 것이 좋다

**AUTO-INCREMENT 칼럼을 인조 식별자로 사용할 경우**

- 여러 개의 칼럼으로 프라이머리 키를 생성하는 경우 프라이머리 키의 크기가 길어질 수 있는데, 이때 보조 인덱스까지 함께 존재한다면 메모리를 많이 소모하기 때문에 이런 경우 AUTO-INCREMENT 칼럼을 추가하고 이를 프라이머리 키로 설정
- 이렇게 프라이머리 키를 대체하기 위해 인위적으로 추가된 프라이머리 키를 인조 식별자(Surrogate key)라고 함
- 그리고 로그 테이블과 같이 조회보다는 INSERT위주의 테이블들은 AUTO-INCREMENT를 이용한 인조 식별자를 프라이머리 키로 설정하는 것이 성능 향상에 도움이 됨

## 5.10 유니크 인덱스

- 유니크란 사실 인덱스라기보다는 제약 조건에 속함. MySQL에서는 인덱스 없이 유니크 제약만 설정할 방법이 없기 때문에 유니크 인덱스 사용
- 유니크 인덱스에서 NULL도 저장될 수 있는데, NULL은 특정의 값이 아니므로 2개 이상 저장 가능
- MySQL에서 프라이머리 키는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여됨
- MyISAM, MEMORY 엔진의 경우 프라이머리 키는 사실 NULL이 허용되지 않는 유니크 인덱스와 같음
- InnoDB 엔진의 경우는 프라이머리키가 클러스터 키의 역할도 하기 때문에 유니크 인덱스와는 근본적으로 다름

### 5.10.1 유니크 인덱스와 일반 보조 인덱스의 비교

- 유니크 인덱스와 일반 보조 인덱스는 구조상 아무런 차이점이 없음
- 읽기와 쓰기를 성능 관점에서 비교해보자

**인덱스 읽기**

- 많은 사람들이 유니크 인덱스가 빠르다고 생각하지만 사실은 아니다.
- 유니크하지 않은 보조인덱스는 중복된 값이 허용되므로 읽어야할 레코드가 많아서 느린 것이지, 인덱스 자체의 특성 때문에 느린 것이 아니라는 것이다.
- 즉 레코드 1건을 읽는데 0.1초가 걸렸고, 2건을 읽을 때 0.2초가 걸렸다고 하면, 후자가 느리게 처리됐다고 할 수 없는 것과 같은 이치다.
- 하나의 값을 검색하는 경우, 유니크 인덱스와 일반 보조 인덱스는 사용되는 실행계획이 다르다. 이는 인덱스의 성격이 유니크한지 아닌지에 따른 차이일뿐 큰 차이는 없다.
- 1개의 레코드를 읽느냐 2개 이상의 레코드를 읽느냐의 차이만 있다는 것을 의미할 뿐, 읽어야할 레코드 건수가 같다면 성능상의 차이는 미미 하다

**인덱스 쓰기**

- 새로운 레코드가 INSERT되거나 인덱스 칼럼 값이 변경되는 경우 인덱스 쓰기 작업이 필요한데, 유니크 인덱스의 키값을 쓸 때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 더 필요
- 또한 MySQL 유니크 인덱스에서 중복된 값을 체크할 때는 읽기 잠금을 사용하고, 쓰기를 할 때는 쓰기 잠금을 사용하는데 이 과정에서 데드락이 빈번하게 발생
- InnoDB 스토리지 엔진에서 인덱스 키의 저장을 버퍼링하기 위해 인서트버퍼(Insert Buffer)가 사용되는데, 유니크 인덱스는 반드시 중복 체크를 위해 디스크 I/O 작업이 필요하기 때문에 인서트 버퍼를 사용하지 못함
- 이러한 이유들 때문에 유니크 인덱스는 일반 보조 인덱스보다 write 처리가 느림

### 5.10.2 유니크 인덱스 사용시 주의사항

- 꼭 필요한 경우라면 유니크 인덱스를 사용하되, 성능이 좋아질 것으로 생각하고 불필요하게 유니크 인덱스를 생성하지 않는 것이 좋음
- 유니크 인덱스와 일반 인덱스를 중복해서 생성해둔 경우가 종종 있는데, 유니크 인덱스는 일반 인덱스 역할을 하므로 중복생성할 필요 없음
- 그리고 프라이머리 키와 유니크 인덱스를 동일하게 생성해둔 경우도 있는데, 프라이머리 키가 유니크 인덱스 역할을 하므로 중복 생성할 필요 없음

## 5.11 외래키

- MySQL에서 외래키는 InnoDB 스토리지 엔진에서만 생성 가능
- 외래키 제약이 설정되면 자동으로 연관된 테이블의 칼럼에 인덱스까지 생성됨
- 외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없음
- 테이블의 변경(쓰기 잠금)이 발생하는 경우에만 잠금 경합(잠금 대기)이 발생
    - 부모테이블에 잠금이 걸려있는 상태에서, 자식테이블에서 외래키 칼럼 변경시 잠금대기 발생
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합(잠금 대기)을 발생시키지 않음
    - 부모테이블에 잠금이 걸려있는 상태에서, 자식테이블에서 외래키가 아닌 칼럼 변경시 잠금대기 발생 안함
- 외래키를 물리적으로 생성하면 외래키가 참조하는 값이 부모테이블에 있는지 확인하는 과정, 체크를 위한 잠금경합 등이 발생하기 때문에 쿼리의 동시 처리 성능에 영향을 미칠 수 있음. 따라서 충분히 고려한 후 외래키를 사용하자!

### 참고

- [https://dev.mysql.com/doc/refman/8.0/en/descending-indexes.html](https://dev.mysql.com/doc/refman/8.0/en/descending-indexes.html)
- [https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html](https://dev.mysql.com/doc/refman/8.0/en/fulltext-boolean.html)
- [https://idea-sketch.tistory.com/44](https://idea-sketch.tistory.com/44)

---
layout: post
title: "Hash 란?"
categories: algorithm
date: 2019-11-22
---


## Hash란 ?
* Hash란 임의의 크기를 가진 데이터를 고정된 크기의 데이터로 변환시키는 것을 말한다. => Hash함수를 통해 데이터를 변환한다 => 해싱(hashing)한다 => 모두 같은 뜻이다.
* Hash알고리즘이란 Hash함수 구현에 대한 명세(?)라고 볼 수 있다.
* Hash함수는 input을 key값이라 하고, output을 해시값이라고 한다 : 해시함수(key) = 해시값
* Hash함수는 반드시 동일한 input에 대해 동일한 output을 내야한다.
* Hash함수는 input에 대해 동일한 output을 내고, 이것이 데이터 저장&탐색의 키값으로 사용 되기때문에 삽입/삭제/탐색이 아주 빠르다. 

## Hash Collision (해시충돌) 
* 해시충돌이란 서로 다른 키값을 해싱했을 때 동일한 해시값이 나오는 현상을 말한다.
* ex) 서로다른 키값 k1, k4에 대해 h(k1) == h(k4) 이러한 결과가 나올 수 있음


## Hash Table 이란 ?
* Hash Table이란 (key&value)로 이루어진 데이터의 key값을 해시값으로 매핑하고, 이 해시값을 index 혹은 주소로 삼아 데이터의 key&value를 저장하는 자료구조를 말한다.
* 이때 데이터가 저장되는 곳을 버킷(bucket) 또는 슬롯(slot)이라고 한다.
* 해시함수의 결과가 일정한 순서를 가진 값이라는 것을 보장할 수 없기 때문에, Hash Table은 순서가 필요한 구조에는 어울리지 않는다.


## Direct Addressing Table
* 데이터의 key 전체개수와 동일한 크기의 버킷을 가진 Hash Table을 말한다.
* 데이터의 key 전체개수라는 것에는 사용되지 않는 key의 개수도 포함되기 때문에, 쓸대 없이 크기가 큰 버킷을 메모리에 할당받아야 한다.
* key의 개수와 Hash Table의 크기가 동일하기 때문에 해시충돌이 발생할 일이 없다.


## Separate Chaining (Chaining 이라고도 한다)
* 해시충돌을 허용하되, 한 버킷당 들어갈 수 있는 엔트리의 수에 제한을 두지 않음으로써 모든 데이터를 해시테이블에 담는 것을 말한다. 
* 동일한 해시값이 발생하면 해당 버킷에 위치하던 기존 데이터의 뒤에 연결 리스트 형태로 엮어 간다.
* key의 개수보다 Hash Table이 작아도 된다.


## Open Addressing
* 하나의 버킷에는 하나의 엔트리만 저장될 수 있는 Hash Table이다.
* Separate Chaining은 엔트리가 항상 해시함수로 얻어진 해시값에 해당하는 버킷에 들어가지만, Open Addressing는 그렇지 않다는 점을 이용한다.
* Open Addressing 에서는 해시값에 해당하는 버킷에 이미 엔트리가 들어가 있다면, 바로 그 다음 버킷에 현재 엔트리를 저장한다.
* 3개의 키(k1, k2, k3)에 대해 동일한 해시값이 나온다면, 3개의 엔트리는 서로 다른 버킷에 순차적으로 저장된다. (버킷1: k1, 버킷2: k2, 버킷3: k3)
  - k2의 값을 삭제하기 위해서 먼저 해시함수를 수행하여 해시값을 찾는다 -> 그 위치에는 k1이 있기 때문에 다음 버킷2를 탐색한다 -> k2이기 때문에 지운다.
  - 그 다음 k3를 삭제할 때 해시함수를 수행하여 해시값을 찾는다 -> 그 위치에는 k1이 있기 때문에 다음 버킷2를 탐색한다 -> 버킷2가 비어있기 때문에 같은 해시값으로 저장된 것이 없다고 판단하고 종료한다. --> 이러한 문제점 때문에 삭제한 버킷에는 어떠한 flag값을 저장해 놓는다. (버킷1: k1, 버킷2: DEL, 버킷3: k3)
* Open Addressing의 해시충돌은 아래에서 설명할 "탐사" 방법과 해싱기법으로 문제를 해결하려 한다.
  - 탐사란 삽입,삭제,탐색을 수행하기 위해 해시테이블 내에 해시값을 찾는 과정을 말한다.


1. Linear probing (선형 탐사)
* 최초 해시값에 해당하는 버킷에 데이터가 저장되어 있으면 "고정폭(ex 한칸)"을 옮긴 버킷에 데이터가 있는지 확인
* 선형탐사는 primary clustring 문제에 취약하다.
  - primary clustring : 특정 해시값 주변에 버킷이 모두 채워져 있는 상태

2. Quadratic probing (제곱 탐사)
* 선형탐사에서 고정폭을 이동하는 것과 달리, 이동 폭이 **해시값에 해당하는 버킷(initial probe)을 기준**으로부터 제곱수로 늘어나는 것을 말함
* 선형탐사는 **이동한 곳에서 부터 또다시 고정폭이동** (해시값에 해당하는 버킷(initial probe)이 기준이 아님)
* 제곱 탐사는 secondary clustering 문제에 취약하다.
  - secondary clustering : 여러 키에 해당하는 해시값이 동일하여 제곱수 만큼 이동해도 버킷이 차 있는 상태

3. Double Hashing (이중 해싱)
* 탐사할 해시값의 규칙성을 없애서 clustering 문제를 방지하는 방법이다.
* 2개의 해시함수를 통해 하나는 최초의 해시값을 얻을때 사용하고, 또다른 하나는 해시충돌이 일어났을때 이동폭을 얻기 위해 사용한다.
* 서로 다른 키에 대해 해시값을 구하는 함수와 이동폭을 구하는 함수의 값이 둘다 동일하게 나오는 경우가 줄어든다.
* 즉, 해시값은 같지만 이동폭을 다르게 하여 탐색하는 횟수를 줄이고, 이동폭은 같지만 해시값을 다르게 하여 탐색하는 횟수를 줄이는 방법이다.


4. 해시함수 자체를 아름답게
* 해시함수 자체를 해시테이블에 크기에 맞게, 해시값을 고르게 만들어주는 함수로 만드는 방법


#### 참고
- <https://d2.naver.com/helloworld/831311>
- <https://velog.io/@cyranocoding/Hash-Hashing-Hash-Table%ED%95%B4%EC%8B%9C-%ED%95%B4%EC%8B%B1-%ED%95%B4%EC%8B%9C%ED%85%8C%EC%9D%B4%EB%B8%94-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%9D%B4%ED%95%B4-6ijyonph6o>
- <https://ratsgo.github.io/data%20structure&algorithm/2017/10/25/hash/>
- <https://hsp1116.tistory.com/35>

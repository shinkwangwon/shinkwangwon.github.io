---
layout: post
title: "분산시스템을 위한 유일ID 생성기 설계"
tags: [SystemArchitecture]
comments: true
date: 2022-04-05
---

# 7장. 분산시스템을 위한 유일ID 생성기 설계

## 7장. 분산 시스템을 위한 유일ID 생성기 설계

auto_increment 속성이 설정된 RDBMS의 기본키를 쓰면 되지 않을까 ?

- DB 서버 한대로 요구를 충족하기에 서버가 충분히 크지 않다
- 여러 DB서버인 경우는 지연시간을 낮추기가 어렵다

### 1단계. 문제 이해 및 설계 범위 확정

요구사항

- ID는 유일해야한다
- ID는 숫자로만 구성되어야 한다
- ID는 64비트로 표현될 수 있는 값이어야 한다
- ID는 발급 날짜에 따라 정렬 가능해야한다
- 초당 10,000개의 ID를 만들 수 있어야 한다

### 2단계. 개략적 설계안 제시 및 동의 구하기

분산 시스템에서 유일성이 보장되는 ID를 만드는 방법은 아래와 같은 선택지가 있다.

- 다중 마스터 복제 (multi-master replication)
- UUID (Universally Unique Identifier)
- 티켓 서버 (ticket server)
- 트위터 스노플레이크 (twitter snowflake) 접근법

**다중 마스터 복제 (multi-master replication)**

![No image](/assets/posts/20220405/Untitled.png)

이 접근법은 데이터베이스의 auto_increment 기능을 활용한다.

다만, 다음 ID 값을 구할 때 1만큼 증가시키지 않고 k 만큼 증가시킨다.

여기서 k 는 현재 사용중인 DB 서버의 개수이다.

장점

- 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있다

단점

- 여러 데이터 센터에 걸쳐 규모를 늘리기 어렵다
- ID의 유일성은 보장되겠지만 그 값이 시간흐름에 맞추어 커지도록 보장할 수는 없다
- 서버의 추가/삭제가 어렵다 (k가 처음 고정되고 나면, 각 서버별로 다음 숫자가 모호해짐)

**UUID (Universally Unique Identifier)**

UUID는 컴퓨터 시스템에 저장되는 정보를 식별하기 위한 128비트 식별자 (16진수)

UUID의 충돌가능성은 지극히 낮다.

*(위키피디아 : 중복 UUID가 1개 생길 확률을 50%로 끌어 올리려면 초당 10억 개의 UUID를 100년 동안 계속해서 만들어야 한다)*

UUID는 서버 간 조율 없이 독립적으로 생성 가능하다.

![No image](/assets/posts/20220405/Untitled1.png)

장점

- UUID를 만드는 것은 단순하며, 서버 사이의 조율이 필요 없으므로 동기화 이슈도 없다.
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다

단점

- ID가 128비트로 길다. 이번 장에서 다루는 문제의 요구사항은 64비트다.
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자 아닌 값이 포함될 수 있다.

**티켓 서버 (ticket server)**

티켓 서버는 유일성이 보장되는 ID를 만들어 내는데 쓰이는 또 하나의 방법

![No image](/assets/posts/20220405/Untitled2.png)

이 아이디어의 핵심은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙집중형으로 하나만 사용하는 것이다.

장점

- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고, 중소 규모 애플리케이션에 적합하다.

단점

- 티켓 서버가 SPOF(Single-Point-of-Failure)가 된다. 이 서버에 장애가 발생하면, 해당 서버를 이용하는 모든 시스템이 영향을 받는다. 이 이슈를 피하려면 티켓 서버를 여러대 준비해야 한다. 하지만 그렇게 하면 데이터 동기화와 같은 새로운 문제가 발생할 것이다.

**트위터 스노플레이크 (twitter snowflake) 접근법**

트위터는 스노플레이크라는 독창적인 ID 생성 기법을 사용한다.

ID를 바로 생성하는 대신 ID의 구조를 여러 section으로 분할한다.

![No image](/assets/posts/20220405/Untitled3.png)

- sign 비트 (1비트) : 당장 쓰임새는 없지만 나중을 위해 확보해둔다. (양수/음수 구별)
- 타임스탬프 (41비트) : 사용자가 지정한 기원시각(epoch) 이후 몇 밀리초가 경과했는지 나태는다. (교재에서는 트위터의 기원시각을 사용한다. 2010년 11월 4일 01:42:54 UTC ⇒ 1288834974657)
- 데이터센터 ID (5비트) : 2^5 = 32개 데이터센터를 지원할 수 있다.
- 서버 ID (5비트) : 데이터 센터당 32개 서버를 사용할 수 있다.
- 일련변호 (12비트) : 각 서버에서 ID 생성할 때마다 일련번호를 1씩 증가시킨다. 이 값은 1밀리초가 경과할 때마다 0으로 초기화(reset)된다.

### 3단계. 상세 설계

2단계의 선택지 중 트위터 스노플레이크 접근법을 채택한다.

![No image](/assets/posts/20220405/Untitled3.png)

ID 구조 다이어 그램을 다시보면,

데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않는다. 두 가지를 잘못변경하게 되면 ID충돌이 발생할 수 있다. 

타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다. 

**타임스탬프**

타임스탬프는 시간의 흐름에 따라 점점 큰 값을 갖게 되므로, 결국 ID는 시간순으로 정렬 가능하게 된다.

ID의 이진수로 되어있는 타임스탬프 값을 UTC시각으로 추출하는 예제다.

![No image](/assets/posts/20220405/Untitled4.png)

41비트로 표현할 수 있는 타임스탬프의 최대값은 2^41 - 1 = 2199023255551 = 대략 69년 이다.

따라서 이 ID 생성기는 69년 동안만 정상 동작한다. 69년이 지나면 기원시각(epoch)을 바꾸거나 ID체계를 다른 것으로 이전해야한다.

**일련번호**

일련번호는 12비트 이므로 2^12 = 4096개의 값을 가질 수 있다.

어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게 된다. (일련번호는 1밀리세컨드마다 0으로 초기화되도록 해놓았기 때문에)

하나의 서버에서 1밀리 세컨트마다 최대 4096개의 ID를 만들어낼 수 있다. 1초에 4096 * 1000 개를 만들어 낼 수 있기 때문에 초당 1만개의 ID를 생성해야한다는 요구사항을 충족할 수 있다.

### 4단계. 마무리

이번 장에서 유일한 ID를 만들 수 있는 4가지의 방법 중 요구사항을 만족할 수 있고 분산환경에도 적합한 트위터의 snowflake 를 선택했다.

시간이 남았다면 다음을 추가로 논의해보자

시계 동기화(clock synchronization) 

- 이번 설계에서 ID 생성 서버들이 전부 같은 시계를 사용한다고 가정했다.
- 모든 서버가 전부 같은 시간 값을 가진다고 확신할 수는 없다.
- NTP (Network Time Protocol)은 이 문제를 해결하는 가장 보편적 수단이다.
- *NTP 는 인터넷을 통해 서버의 시간을 최상위 동기 클럭원(Master Clock)에 동기시키는 프로토콜. 쉽게 말해, 각 서버들이 Local 시간이 아닌 공통의 Time Server로 부터 시간을 받아와서 사용하는 것이라고 생각하면 됨*

각 section의 길이 최적화 

- 동시성이 낮고 수명이 긴 애플리케이션이라면 일련번호 절의 길이를 줄이고 타임스탬프 절의 길이를 늘리는 것이 효과적일 수 있을 것이다.

고가용성(high availability)

- ID 생성기는 필수 불가결(mission critical) 컴포넌트이므로 아주 높은 가용성을 제공해야 할 것이다.


### 참고
- 가상 면접 사례로 배우는 대규모 시스템 설계 기초
- http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788966263158&orderClick=LAG&Kc=
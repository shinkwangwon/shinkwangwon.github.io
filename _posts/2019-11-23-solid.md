---
layout: post
title: "객체지향 설계 5대 원칙"
categories: java
date: 2019-11-23
---


## 결합도(Coupling), 응집도(Cohesion)
- 결합도 : 코드의 한 요소가 다른것과 얼마나 강력하게 연결되어 있는지, 얼마나 의존적인지 나타내는 정도
- 응집도 : 코드의 한 요소가 어떠한 기능을 수행하기 위해 얼마만큼의 책임과 기능들이 모여서 구성되어 있는지를 나타내는 정도
- 결합도가 낮고 응집도가 높을수록 좋은 모듈화가 된것이다.
- 그렇다고 극단적으로 낮고 높다고 다 좋은건 아니다. 과유불급


## 객체지향 5대 원칙
- SRP (Single Responsibility Principle : 단일 책임의 원칙)
- OCP (Open Close Principle : 개방 폐쇄의 원칙)
- LSP (Liskov Substitution Principle : 리스코브 치환의 원칙)
- ISP (Interface Segregation Principle : 인터페이스 분리의 원칙)
- DIP (Dependency Inversion Principle : 의존성 역전의 원칙)

1. SRP (Single Responsibility Principle : 단일 책임의 원칙)
- 클래스는 하나의 책임(기능)만을 가져야 한다. 즉, 어떤 클래스를 변경해야 하는 이유는 오직 하나 뿐이어야 한다는 원칙.
- 쉽게 말해 클래스에 너무 많은 기능을 때려박지 말자는 뜻

2. OCP (Open Close Principle : 개방 폐쇄 원칙)
- 소프트웨어의 구성요소(클래스, 모듈, 함수 등)는 확장에 대해서는 열려 있어야 하고 변경에 대해서는 닫혀 있어야 한다는 원칙.
- 즉, 어떠한 변경사항이 발생했을 때 기존 구성요소는 최대한 건드리지 않고, 기존 구성요소 재사용을 통해 쉽게 확장해서 처리할 수 있어야 한다는 뜻
- 예를들어, 비교적 변화가 없을 것이라고 판단되는 공통적인 부분을 하나의 모듈(클래스 또는 인터페이스)로 빼내고 그것을 확장해가며 변경사항에 적응

3. LSP (Liskov Substitution Principle : 리스코브 치환 원칙)
- 서브 타입은 언제나 자신의 기반타입으로 교체할 수 있어야 한다는 원칙.
- 하위 클래스의 인스턴스를 상위 클래스 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.
- 아주 이해하기 쉬운 예제를 퍼옴
- 아래 코드에서 List 또는 HashSet을 modify인자로 쓰고 싶을때, modify메서드의 파라미터 타입을 List와 HashSet의 인터페이스인 Collection으로 설정
- ```java
    void f(){  
        Collection collection = new HashSet(); // List와 HashSet은 Collection인터페이스의 구현체
        //…
        modify(list);
        }

    void modify(Collection collection){     // 업캐스팅되어 상위 타입의 참조변수에 저장된 HashSet을 받아서 논리적으로 처리하는데 전혀 문제가 없음 
        collection.add(…);
        doSomethingWith(collection);
    }
  ```

4. ISP (Interface Segregation Principle : 인터페이스 분리 원칙)
- 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다는 원칙.
- 즉, 인터페이스에서 상황과 관련있는 메서드만 제공하라는 뜻 (= 하나의 일반적인 인터페이스보다는, 여러 개의 구체적인 인터페이스가 낫다)
- 어떤 클래스에서 인터페이스를 구현(implements)했는데, 그 클래스에서 사용하지 않는 메소드까지 받지 않도록 인터페이스를 분리하라는 말!
- SRP가 클래스의 단일책임을 강조한다면, ISP는 인터페이스의 단일책임을 강조한다.


5. DIP (Dependency Inversion Principle : 의존성 역전의 원칙)
- 추상화 된 것은 구체적인 것에 의존하면 안된다. 구체적인 것이 추상화 된 것에 의존해야 한다는 원칙
- 추상클래스, 상위클래스는 구현클래스 또는 하위클래스에게 의존적이면 안된다는 뜻이다.
- 추상클래스와 구현클래스만을 예로 들면, 구현클래스가 바뀐다고 추상클래스가 바뀌는 것은 추상클래스가 구현클래스에 의존하고 있다는 말과 같다.
- 이런 경우 구현클래스가 바뀌고 추상클래스가 바뀌면서, 추상클래스의 상위와 또 그상위가 연쇄적으로 변화가 일어날 수 있기 때문에 문제가 될 수 있다.
- 이런 문제가 발생했을 때, 추상클래스를 인터페이스 같은 것으로 한번 더 추상화하여 변화에 민감하지 않은 것으로 만들고 구현클래스에서는 이렇게 한번 더 추상화된 놈을 사용하도록 한다.
- 이렇게 되면 기존의 추상클래스는 구현클래스에 의존하고 있었는데, 한번더 추상화된 인터페이스를 의존하게 된다 (의존성이 역전됨)


#### 참고
- <http://www.nextree.co.kr/p6960/>
- <https://limkydev.tistory.com/77>